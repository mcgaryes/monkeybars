<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>..&#x2F;source&#x2F;group.js - MonkeyBars</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0pr2&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0pr2&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="MonkeyBars"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.9.11</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/MonkeyBars.html">MonkeyBars</a></li>
            
                <li><a href="..&#x2F;classes/ParallelTask.html">ParallelTask</a></li>
            
                <li><a href="..&#x2F;classes/SequenceTask.html">SequenceTask</a></li>
            
                <li><a href="..&#x2F;classes/Task.html">Task</a></li>
            
                <li><a href="..&#x2F;classes/TaskGroup.html">TaskGroup</a></li>
            
                <li><a href="..&#x2F;classes/WorkerTask.html">WorkerTask</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: ..&#x2F;source&#x2F;group.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * A task group, and extention of task, provides the building blocks for creating
 * a group of tasks that is inherently a task itself.
 *
 * @extends Task
 * @constructor
 * @class TaskGroup
 * @param {Object} attributes List of attributes to apply to the task group
 *&#x2F;
var TaskGroup = MonkeyBars.TaskGroup = function(attributes) {
	var task = this;

	if(attributes &amp;&amp; attributes.tasks) {
		task.tasks = createSubTasksFromTaskOptionsArray(attributes.tasks);
	}

	&#x2F;&#x2F; create dependency map and populate it with subtask tids
	task.dependencyMap = {};
	if(task.tasks) {
		for(var i = 0; i &lt; task.tasks.length; i++) {
			var subtask = task.tasks[i];
			this.dependencyMap[subtask.tid] = [];
			task.setDependeciesForTask(subtask);
		}
	}

	&#x2F;&#x2F; super
	Task.call(task, attributes);
};

TaskGroup.prototype = Object.create(Task.prototype, {

	&#x2F;**
	 * Adds a subtask to the groups queue. This is helpful when you want to add
	 * a sub task after instantiation.
	 *
	 * @for TaskGroup
	 * @method addSubTask
	 * @param {Object} task Either an object containing attributes of a task or
	 * an already instantiated task
	 * @example
	 *
	 *	var parallel = new MonkeyBars.ParallelTask();
	 *	
	 *	parallel.addSubTask({
	 *		name:&quot;subtask&quot;,
	 *		performTask:function(){
	 *			this.complete();
	 *		}
	 *	});
	 *
	 *	var simple = new MonkeyBars.simple({
	 *		name:&quot;subtask&quot;,
	 *		performTask:function(){
	 *			this.complete();
	 *		}
	 *	});
	 *
	 *	parallel.addSubTask(simple);
	 *
	 *&#x2F;
	addSubTask: {
		value: function(task) {
			if(!task) {
				throw &quot;addSubTask: &quot; + INVALID_ARGUMENTS;
			}
			if(!task.tid) {
				task = createTaskWithOptions(task);
			}
			this.setDependeciesForTask(task);
			this.tasks.push(task);
		},
		writable: true
	},

	&#x2F;**
	 * Adds a subtask after another task
	 *
	 * @for TaskGroup
	 * @method addSubTaskAfterTask
	 * @param {Object} task Either an object containing attributes of a task or
	 * @param {Object} afterTask Reference to an already added task
	 * @example
	 *
	 *	var parallel = new MonkeyBars.ParallelTask({
	 *		tasks:[task1,task3]
	 *	});
	 *
	 *	var task2 = new MonkeyBars.Task();
	 *	parallel.addTaskAfterTask(task2,task1);
	 *
	 *&#x2F;
	addSubTaskAfterTask: {
		value: function(task, afterTask) {
			if(!task || !afterTask) {
				throw &quot;addSubTaskAfterTask: &quot; + INVALID_ARGUMENTS;
			}
			if(!task || this.state === STATE_CANCELED) {
				return;
			}
			if(!task.tid) {
				task = createTaskWithOptions(task);
			}
			this.setDependeciesForTask(task);
			&#x2F;&#x2F; @TODO: Need to add the tid of the task and not the task itself
			var index = this.tasks.indexOf(afterTask);
			this.tasks.splice(index + 1, 0, task);
		},
		writable: true
	},

	&#x2F;**
	 * Very similar to &#x60;addSubTaskAfterTask&#x60; except the inject task appears
	 * before the second arguments position.
	 *
	 * @for TaskGroup
	 * @method addSubTaskBeforeTask
	 * @param {Object} task Either an object containing attributes of a task or
	 * @param {Object} beforeTask Reference to an already added task
	 *&#x2F;
	addSubTaskBeforeTask: {
		value: function(task, beforeTask) {
			if(!task || !beforeTask) {
				throw &quot;addSubTaskBeforeTask: &quot; + INVALID_ARGUMENTS;
			}
			if(!task || this.state === STATE_CANCELED) {
				return;
			}
			if(!task.tid) {
				task = createTaskWithOptions(task);
			}
			this.setDependeciesForTask(task);
			&#x2F;&#x2F; @TODO: Need to add the tid of the task and not the task itself
			var index = this.tasks.indexOf(beforeTask);
			this.tasks.splice(index, 0, task);
		},
		writable: true
	},

	&#x2F;**
	 * Cancel the group and cancel all of its subtasks
	 *
	 * @for TaskGroup
	 * @method cancel
	 *&#x2F;
	cancel: {
		value: function() {

			&#x2F;&#x2F; call cancel on this task
			Task.prototype.cancel.call(this);

			&#x2F;&#x2F; cancel all of this tasks subtasks
			for(var i = 0; i &lt; this.tasks.length; i++) {
				&#x2F;&#x2F; we only want to cancel those tasks that are currently running
				&#x2F;&#x2F; otherwise we want to set the canceled flag
				&#x2F;&#x2F; @TODO: Need to reference the task through the tid
				var task = this.tasks[i];
				if(task.state &gt; STATE_INITIALIZED) {
					task.cancel();
				} else {
					task.state = STATE_CANCELED;
				}
			}
		},
		writable: true
	},

	&#x2F;**
	 * The index of the subtasks that have completed execution.
	 *
	 * @for TaskGroup
	 * @property currentIndex
	 * @type Integer
	 * @readonly
	 * @default 0
	 *&#x2F;
	currentIndex: {
		value: 0,
		writable: true
	},

	&#x2F;**
	 * Return a Task object, if it exists, based on the &#x60;name&#x60; passed.
	 *
	 * @for TaskGroup
	 * @method getTaskByName
	 * @param {String} name The user defined name
	 *&#x2F;
	getTaskByName: {
		value: function(name) {
			&#x2F;&#x2F; @TODO: Need to reference the task through the tid
			for(var i = 0; i &lt; this.tasks.length; i++) {
				var task = this.tasks[i];
				if(task.name === name) {
					return task;
				}
			}
		},
		writable: true
	},

	&#x2F;**
	 * Return a Task object, if it exists, based on the &#x60;tid&#x60; passed.
	 *
	 * @for TaskGroup
	 * @method getTaskByTid
	 * @param {String} tid The id of the task you want
	 * @example
	 *
	 *	var parallel = new MonkeyBars.ParallelTask({
	 *		tasks:[task1,task3]
	 *	});
	 *
	 *	parallel.getTaskByTid(task1.tid);
	 *
	 *&#x2F;
	getTaskByTid: {
		value: function(tid) {
			&#x2F;&#x2F; @TODO: Need to reference the task through the tid
			for(var i = 0; i &lt; this.tasks.length; i++) {
				var task = this.tasks[i];
				if(task.tid === tid) {
					return task;
				}
			}
		},
		writable: true
	},

	&#x2F;**
	 * Called when a subtask calls its cancel method. When a subtask is canceled
	 * any other subtasks that are dependent on the canceled task are cancled.
	 *
	 * @for TaskGroup
	 * @method onSubTaskCancel
	 * @param {Task} task The task that was just canceled
	 *&#x2F;
	onSubTaskCancel: {
		value: function(task) {
			for(var i = 0; i &lt; this.tasks.length; i++) {
				if(isTaskDependentOnTask(this.tasks[i], task)) {
					&#x2F;&#x2F; @TODO: Need to reference the task through the tid
					this.tasks[i].state = STATE_CANCELED;
				}
			}
		},
		writable: true
	},

	&#x2F;**
	 * Called when a sub task completes. Must be overridden with functionality
	 * provided by the extending class.
	 *
	 * @for TaskGroup
	 * @method onSubTaskComplete
	 * @param {Task} task The task that just completed
	 *&#x2F;
	onSubTaskComplete: {
		value: function(task) {
			&#x2F;&#x2F; @TODO: Need to reference the task through the tid
			this.operate(task.data,task);
		},
		writable: true
	},

	&#x2F;**
	 * Called when a subtask calls its fault method.
	 *
	 * @for TaskGroup
	 * @method onSubTaskFault
	 * @param {String} error Error message.
	 * @param {Task} task The task that just completed
	 *&#x2F;
	onSubTaskFault: {
		value: function(task, error) {
			this.fault(error);
		},
		writable: true
	},

	&#x2F;**
	 * An incrimented number of the tasks that have already been processed.
	 *
	 * @for ParallelTask
	 * @property processedIndex
	 * @type Integer
	 *&#x2F;
	processedIndex: {
		value: 0,
		writable: true
	},

	&#x2F;**
	 * Processes a sub task and prepares it for execution. This method overwrites the
	 * tasks on change functionality. If you wish to have a sub task that handles
	 * its own change functionality then you will need to implement the partner
	 * convenience methods.
	 *
	 * @for TaskGroup
	 * @method processSubTask
	 * @param {Task} task Subtask to process
	 *&#x2F;
	processSubTask: {
		value: function(task) {

			if(!task) {
				if(this.logLevel &gt;= LOG_ERROR) {
					log(UNDEFINED_TASK);
				}
				return;
			}

			if(task.state === STATE_CANCELED) {
				this.onSubTaskCancel(task);
				return true;
			}

			this.processedIndex++;

			task.group = this;
			task.processed = true;
			if(task.concurrent) {
				task.concurrent = this.concurrent;
			}
			if(task.logLevel !== LOG_NONE) {
				task.logLevel = this.logLevel;
			}
			
			&#x2F;&#x2F; set execution block
			var group = this;
			task.onChange = function(state, error) {
				if(state === STATE_COMPLETED) {
					group.onSubTaskComplete(this);
				} else if(state === STATE_FAULTED) {
					group.onSubTaskFault(this, error);
				} else if(state === STATE_CANCELED) {
					group.onSubTaskCancel(this);
				}
			};

			task.start();

			return false;
		},
		writable: true
	},

	&#x2F;**
	 * Removes a task from its group. Removing the task after it has executed will
	 * have no apparent affect as it has already ran.
	 *
	 * @for TaskGroup
	 * @method removeSubTask
	 * @param {Task} task The task you wish to remove from the group.
	 *&#x2F;
	removeSubTask: {
		value: function(task) {
			if(!task) {
				return;
			}
			var index = this.tasks.indexOf(task);
			this.tasks.splice(index, 1);
		},
		writable: true
	},

	&#x2F;**
	 * Resets a task to its original state
	 *
	 * @for Task
	 * @method reset
	 *&#x2F;
	reset:{
		value:function(){
			if(this.tasks) {
				this.currentIndex = 0;
				this.processedIndex = 0;
				for(var i = 0; i &lt; this.tasks.length; i++) {
					this.tasks[i].reset();
				}
			}
			Task.prototype.reset.call(this);
		}
	},

	&#x2F;**
	 * Sets dependencies for the passed task.
	 *
	 * @method setDependeciesForTask
	 * @param {Task} task
	 * @static
	 *&#x2F;
	setDependeciesForTask: {
		value: function(task) {
			if(task.dependencies) {
				var totalDependencies = task.dependencies.length;
				for(var i = 0; i &lt; totalDependencies; i++) {
					var dependency = task.dependencies[i];
					if(dependency.tid) {
						this.dependencyMap[task.tid].push(dependency.tid);
					} else {
						this.dependencyMap[task.tid].push(dependency);
					}
				}

			}
		},
		writable: false
	}
});

TaskGroup.extend = extend;
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
