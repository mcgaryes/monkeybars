<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>..&#x2F;source&#x2F;monkeybars.js - MonkeyBars</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0pr2&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0pr2&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="MonkeyBars"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/MonkeyBars.html">MonkeyBars</a></li>
            
                <li><a href="..&#x2F;classes/ParallelTask.html">ParallelTask</a></li>
            
                <li><a href="..&#x2F;classes/SequenceTask.html">SequenceTask</a></li>
            
                <li><a href="..&#x2F;classes/Task.html">Task</a></li>
            
                <li><a href="..&#x2F;classes/TaskGroup.html">TaskGroup</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: ..&#x2F;source&#x2F;monkeybars.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;*!
 *
 * MonkeyBars 
 * 
 * Task library that provides a simple structure for handling singular, sequential 
 * and parallel units of code. 
 *
 * https:&#x2F;&#x2F;github.com&#x2F;mcgaryes&#x2F;monkeybars
 * 
 * @version 0.0.1 
 * @author Eric McGary
 * @module MonkeyBars
 * @main MonkeyBars
 *&#x2F;
(function() {

	&#x2F;&#x2F; ===================================================================
	&#x2F;&#x2F; === Constants =====================================================
	&#x2F;&#x2F; ===================================================================

	var STATE_INITIALIZED	=	0;
	var STATE_STARTED		=	1;
	var STATE_CANCELED		=	2;
	var STATE_FAULTED		=	3;
	var STATE_COMPLETED		=	4;

	var TYPE_PARALLEL		=	&quot;parallel&quot;;
	var TYPE_SEQUENCE		=	&quot;sequence&quot;;
	var TYPE_SIMPLE			=	&quot;simple&quot;;

	var DECORATOR_FOR		=	&quot;for&quot;;
	var DECORATOR_WHEN		=	&quot;when&quot;;
	var DECORATOR_WHILE		=	&quot;while&quot;;

	var TID_PREFIX			=	&quot;tid&quot;;
	var TIMEOUT_INTERVAL	=	100;
	var OVERRIDE_NEEDED		=	&quot;This method must be overridden.&quot;;
	var UNDEFINED_TASK		=	&quot;Task is undefined.&quot;;
	var MISSING_ATTRIBUTES	=	&quot;You must pass some attributes in order to create a task.&quot;;

	&#x2F;&#x2F; ===================================================================
	&#x2F;&#x2F; === Private Variables =============================================
	&#x2F;&#x2F; ===================================================================

	&#x2F;**
     * A dictionary of dependencies for sub tasks
     *
     * @property root
     * @type Object
     * @private
     *&#x2F;
	var root = this;

	&#x2F;**
     * Counter used to create unique task ids
     *
     * @property taskIdCounter
     * @type Integer
     * @private
     *&#x2F;
	var taskIdCounter = 0;

	&#x2F;**
     * Object returned by module. Works as namespace for the task library.
     *
     * @property MonkeyBars
     * @type Object
     *&#x2F;
	var MonkeyBars = root.MonkeyBars = {};

	&#x2F;&#x2F; ===================================================================
	&#x2F;&#x2F; === NodeJS Conditional ============================================
	&#x2F;&#x2F; ===================================================================

	if(typeof exports !== &#x27;undefined&#x27;) {
		if(typeof module !== &#x27;undefined&#x27; &amp;&amp; module.exports) {
			exports = module.exports = MonkeyBars;
		}
	}

	&#x2F;&#x2F; ===================================================================
	&#x2F;&#x2F; === Helper Methods ================================================
	&#x2F;&#x2F; ===================================================================

	&#x2F;**
	 * Creates task based on the options passed.
	 *
	 * @method createTaskWithOptions
	 * @param {Object} options
	 * @private
	 *&#x2F;
	var createTaskWithOptions = function(attributes){

		&#x2F;&#x2F; check for attributes
		if(!attributes) {
			throw MISSING_ATTRIBUTES;
			return;
		}

		var task;
		
		&#x2F;&#x2F; if the attributes passes already has a tid then we know that
		&#x2F;&#x2F; its an already initialized Task object... else we need to create
		&#x2F;&#x2F; a task from the attributes passed
		if(attributes.tid) {

			task = attributes;

		} else {

			var type = attributes.type;
			var tasks = attributes.tasks;

			&#x2F;&#x2F; create any subtasks
			if (tasks) attributes.tasks = createSubTasksFromTaskOptionsArray(tasks);

			if(type) {
				if(type == TYPE_SIMPLE) {
					task = new Task(attributes);
				} else if(type == TYPE_SEQUENCE) {
					task = new SequenceTask(attributes);
				} else if(type == TYPE_PARALLEL){
					task = new ParallelTask(attributes);
				}
			} else {
				if (!tasks) {
					task = new Task(attributes);
				} else {
					task = new SequenceTask(attributes);
				}
			}

		}

		return task;
	}

	&#x2F;**
	 * Creates an array of tasks based on the options array passed.
	 *
	 * @method createSubTasksFromTaskOptionsArray
	 * @param {Array} tasks
	 * @private
	 *&#x2F;
	var createSubTasksFromTaskOptionsArray = function(tasks){
		var tempTasks = [];
		if(tasks) {
			for(var i=0;i&lt;tasks.length;i++){
				tempTasks.push(createTaskWithOptions(tasks[i]));
			}
		}
		return tempTasks;
	}

	&#x2F;**
	 * Creates property descriptors from the passes attributes.
	 *
	 * @method createPropertyDescriptorsWithAttributes
	 * @param {Object} attributes
	 * @private
	 *&#x2F;
	var createPropertyDescriptorsWithAttributes = function(attributes){
		var descriptors = {};
		for (var attribute in attributes) {
			&#x2F;&#x2F; @TODO: If the attribute in question already has property descriptors then carry those over
			descriptors[attribute] = { 
				value: attributes[attribute],
				writable:true,
				configurable:true,
				enumerable:true
			};
		}
		return descriptors;
	}

	&#x2F;** 
	 * Resets the task to its original non executed state.
	 *
	 * @method resetTask
	 * @param {Object} task
	 * @private
	 *&#x2F;
	var resetTask = function(task){
		task.state = STATE_INITIALIZED;
		if(task.type != TYPE_SIMPLE &amp;&amp; task.tasks){
			task.currentIndex = 0;
			for (var i = 0; i &lt; task.tasks.length; i++) {
				resetTask(task.tasks[i]);
			};
		}
	}

	&#x2F;**
	 * Generates a unique id for each task.
	 *
	 * @method generateUniqueId
	 * @param {String} prefix
	 * @return {String} tid
	 * @private
	 *&#x2F;
	var generateUniqueId = function(prefix){
  		var id = taskIdCounter++;
  		var tid = prefix ? prefix + id : TID_PREFIX + id;
  		return tid;
	}

	&#x2F;**
	 * Determains whether the first task is dependent on the second.
	 *
	 * @method isTaskDependentOnTask
	 * @param {Task} task1
	 * @param {Task} task2
	 * @private
	 *&#x2F;
	var isTaskDependentOnTask = function(task1,task2) {
		var dependencies = task1.dependencies;
		if(dependencies) {
			var totalDependencies = dependencies.length;
			for (var i = 0; i &lt;totalDependencies; i++) {
				var dependency = dependencies[i];
				if (dependency == task2.tid) {
					return true;
				} else if (dependency == task2.id) {
					return true;
				} else if (dependency == task2.name &amp;&amp; task2.name !== &quot;undefined&quot;) {
					return true;
				}
			}
		}
		return false;
	}

	&#x2F;**
	 * Extention functionality for various task types.
	 *
	 * @method extend
	 * @for MonkeyBars
	 * @param {Object} protoProps
	 * @return {Function} child Constructor function for extended task type
	 * @example
			
			var CustomTask = MonkeyBars.Task.extend({
				name:&quot;CustomTask&quot;,
				newMethod:function(){
					console.log(&quot;Executing newMethod&quot;);
				}
			});

			var instance = new CustomTask();

	 *&#x2F;
	var extend = function(protoProps) {
		var parent = this;
		var child = function(){ parent.apply(this, arguments); };
		var childProto = createPropertyDescriptorsWithAttributes(protoProps);
		child.prototype = Object.create(parent.prototype,childProto);
		return child;
	}

	&#x2F;&#x2F; ===================================================================
	&#x2F;&#x2F; === Tasks Objects =================================================
	&#x2F;&#x2F; ===================================================================

	&#x2F;**
	 * The simplest form of a __MonkeyBars__ task. Once started the task executes all 
	 * functionality located within the &#x60;performTask&#x60; function block. Set &#x60;loggingEnabled&#x60;
	 * to see console logs during task execution.
	 * 
	 * @extends Object
	 * @constructor
	 * @class Task
	 * @param {Object} attributes List of attributes to apply to the task
	 * @example
			
			var task = new MonkeyBars.Task({
				name:&quot;ExampleTask&quot;,
				performTask:function(){
					this.complete();
				},
				onComplete:function(){
					alert(this.name + &quot; is complete!&quot;);
				}
    		});

    		task.start();

	 *&#x2F;
	var Task = MonkeyBars.Task = function(attributes) {
	 
	 	&#x2F;&#x2F; refernce for readability
	 	var task = this;
	 	task.tid = generateUniqueId();

	 	&#x2F;&#x2F; add our attributes
	 	for (var prop in attributes) {
			if (!task.hasOwnProperty(prop)) {
				task[prop] = attributes[prop];
			}
		}

	 	&#x2F;&#x2F; decorate out task
	 	task.decorators = [];
		if(task.count) ForTaskDecorator(task);
		if(task.when) WhenTaskDecorator(task);
		if(task.while) WhileTaskDecorator(task);
	}

	Task.prototype = Object.create({}, {
		
		&#x2F;**
		 * The kind of task 
		 * 
		 * @for Task
		 * @property type
		 * @type String
		 * @readonly
		 *&#x2F;
		type: {
			get: function() {
				return TYPE_SIMPLE;
			}
		},

		&#x2F;**
		 * Display name for task. Used in logging output.
		 * 
		 * @for Task
		 * @property displayName
		 * @type String
		 * @readonly
		 *&#x2F;
		displayName: {
			get: function() {
				if(this.id) return this.id;
				if(this.name) return this.name;
				return this.type;
			}
		},

		&#x2F;**
		 * The current state of the task
		 * 
		 * @for Task
		 * @property state
		 * @type Integer
		 * @readonly
		 * @default 0
		 *&#x2F;
		state: {
			value: STATE_INITIALIZED,
			writable: true
		},

		&#x2F;**
		 * Calling this method cancels the task. However it is up to the instance to handle 
		 * the canceled state.
		 * 
		 * @for Task
		 * @method cancel
		 * @example

			var task = new MonkeyBars.Task({
				performTask:function(){
					if(true){
						this.cancel();
					}
				}
			});

			task.start();

		 *&#x2F;
		cancel: {
			value: function() {
				if(this.state &gt; STATE_STARTED) return;
				this.state = STATE_CANCELED;
				if(this.loggingEnabled) console.log(&quot;Canceled:&quot; + this.displayName);
				this.onChange(this.state);
				this.onCancel();
			},
			writable: true
		},

		&#x2F;**
		 * Calling this method says that the tasks execution is now complete.
		 * 
		 * @for Task
		 * @method complete
		 * @example

			var task = new MonkeyBars.Task({
				performTask:function(){
					this.complete();
				}
			});

			task.start();

		 *&#x2F;
		complete: {
			value: function() {
				if(this.state &gt; STATE_STARTED) return;
				this.state = STATE_COMPLETED;
				if(this.loggingEnabled) console.log(&quot;Completed:&quot; + this.displayName);
				this.executionTime = (new Date().getTime()) - this.startTime;
				this.onComplete();
				this.onChange(this.state);
			},
			writable: true
		},

		&#x2F;**
		 * Calling this method to fault a task. If it is part of a group task this will 
		 * also call the groups fault method passing the error up to the group.
		 * 
		 * @for Task
		 * @method fault
		 * @param {String} error Message associated with the cause of the fault.
		 * @example

			var task = new MonkeyBars.Task({
				performTask:function(){
					var a = &quot;a&quot;;
					if(a != &quot;b&quot;) {
						this.fault(&quot;a != b&quot;);
					}
				}
			});

			task.start();

		 *&#x2F;
		fault: {
			value: function(error) {
				if(this.state &gt;= STATE_CANCELED) return;
				this.state = STATE_FAULTED;
				if(this.loggingEnabled) console.log(&quot;Faulted:&quot; + this.displayName);
				this.onChange(this.state, error);
				this.onFault(error);
			},
			writable: true
		},

		&#x2F;**
		 * This method is called during the execution lifecycle of the task. It is intentionally
		 * left blank and is up to the instance to describe it functionality.
		 * 
		 * @for Task
		 * @method onChange
		 * @param {Integer} state The current state of the task
		 * @param {String} error Message describing error
		 * @example

			var task = new MonkeyBars.Task({
				performTask:function(){
					this.complete();
				},
				onChange:function(state,error){
					if(state == MonkeyBars.TaskStates.Completed){
						alert(&quot;complete&quot;);
					}
				}
			});

			task.start();

		 *&#x2F;
		onChange: {
			value: function(state, error) {},
			writable: true
		},

		&#x2F;**
		 * Convenience method called when the task starts.
		 * 
		 * @for Task
		 * @method onStart
		 *&#x2F;
		onStart: {
			value: function() {},
			writable: true
		},

		&#x2F;**
		 * Convenience method called when the task faults.
		 * 
		 * @for Task
		 * @method onFault
		 * @param {String} error Message describing error
		 *&#x2F;
		onFault: {
			value: function(error) {},
			writable: true
		},

		&#x2F;**
		 * Convenience method called when the task completes.
		 * 
		 * @for Task
		 * @method onComplete
		 *&#x2F;
		onComplete: {
			value: function() {},
			writable: true
		},

		&#x2F;**
		 * Convenience method called when the task is canceled.
		 * 
		 * @for Task
		 * @method onCancel
		 *&#x2F;
		onCancel: {
			value: function() {},
			writable: true
		},

		&#x2F;**
		 * This method is required for **simple** tasks and will throw an exception if it 
		 * is called and not overridden. If you overwrite this method on a task group
		 * then you need to make sure that you call the extended&#x2F;implemented classes
		 * original prototype method (see the example below).
		 * 
		 * @for Task
		 * @method performTask
		 * @required
		 * @example

			var parallel = new MonkeyBars.ParallelTask({
				...
				performTask:function(){
					&#x2F;&#x2F; custom functionality
					MonkeyBars.ParallelTask.prototype.performTask.call(this);
				}
				...
			})

		 *&#x2F;
		performTask: {
			value: function() { throw OVERRIDE_NEEDED; },
			writable: true
		},

		&#x2F;**
		 * Kicks off the execution of the task by calling the tasks &#x60;performTask&#x60; method. 
		 * This method can only be run once on a task.
		 * 
		 * @for Task
		 * @method start
		 *&#x2F;
		start: {
			value:function() {
				if(this.state &gt;= STATE_STARTED) return;
				this.startTime = new Date().getTime();
				this.state = STATE_STARTED;
				if(this.loggingEnabled) console.log(&quot;Started:&quot; + this.displayName);
				this.onChange(this.state);
				this.performTask();
				this.onStart();
			},
			writable: true
		}
	});
	
	&#x2F;**
	 * A task group, and extention of task, provides the building blocks for creating
	 * a group of tasks that is inherently a task itself. 
	 * 
	 * @extends Task
	 * @constructor
	 * @class TaskGroup
	 * @param {Object} attributes List of attributes to apply to the task group
	 *&#x2F;
	var TaskGroup = MonkeyBars.TaskGroup = function(attributes) {
	 	&#x2F;&#x2F; refernce for readability
	 	var task = this;

	 	&#x2F;&#x2F; custom functionality
	 	if(attributes) task.tasks = createSubTasksFromTaskOptionsArray(attributes.tasks);

	 	&#x2F;&#x2F; create dependency map and populate it with subtask tids
	 	task.dependencyMap = {};
	 	if(task.tasks){
		 	for (var i = 0; i &lt; task.tasks.length; i++) {
		 		var subtask = task.tasks[i];
		 		this.dependencyMap[subtask.tid] = [];
				task.setDependeciesForTask(subtask);
		 	};
	 	}

	 	&#x2F;&#x2F; super
	 	Task.call(task,attributes);
	 }

	TaskGroup.prototype = Object.create(Task.prototype, {
		
		&#x2F;**
		 * The index of the subtasks that have completed execution.
		 * 
		 * @for Task
		 * @property currentIndex
		 * @type Integer
		 * @readonly
		 * @default 0
		 *&#x2F;
		currentIndex: {
			value: 0,
			writable: true
		},

		&#x2F;**
		 * Adds a subtask to the groups queue. This is helpful when you want to add
		 * a sub task after instantiation.
		 * 
		 * @for TaskGroup
		 * @method addSubTask
		 * @param {Object} task Either an object containing attributes of a task or
		 * an already instantiated task
		 * @example

			var parallel = new MonkeyBars.ParallelTask();
			
			parallel.addSubTask({
				name:&quot;subtask&quot;,
				performTask:function(){
					this.complete();
				}
			});

			var simple = new MonkeyBars.simple({
				name:&quot;subtask&quot;,
				performTask:function(){
					this.complete();
				}
			});
			parallel.addSubTask(simple);


		 *&#x2F;
		addSubTask: {
			value: function(task) {
				if(!task.tid) task = createTaskWithOptions(task);
				this.setDependeciesForTask(task);
				this.tasks.push(task);
			},
			writable: true
		},

		&#x2F;**
		 * description
		 * 
		 * @for TaskGroup
		 * @method addSubTaskAfterTask
		 * @param {Object} task Either an object containing attributes of a task or
		 * @param {Object} afterTask Reference to an already added task
		 * @example

			var parallel = new MonkeyBars.ParallelTask({
				tasks:[task1,task3]
			});

			var task2 = new MonkeyBars.Task();
			parallel.addTaskAfterTask(task2,task1);

		 *&#x2F;
		addSubTaskAfterTask: {
			value: function(task, afterTask) {
				if(!task || this.state == STATE_CANCELED) return;
				if(!task.tid) task = createTaskWithOptions(task);
				this.setDependeciesForTask(task);
				var index = this.tasks.indexOf(afterTask);
				this.tasks.splice(index, 0, task);
			},
			writable: true
		},

		&#x2F;**
		 * Called when a sub task completes. Must be overridden with functionality 
		 * provided by the extending class.
		 * 
		 * @for TaskGroup
		 * @method onSubTaskComplete
		 *&#x2F;
		onSubTaskComplete: {
			value: function() { throw OVERRIDE_NEEDED; },
			writable: true
		},

		&#x2F;**
		 * Called when a subtask calls its fault method.
		 * 
		 * @for TaskGroup
		 * @method onSubTaskFault
		 * @param {String} error Error message.
		 *&#x2F;
		onSubTaskFault: {
			value: function(error) { this.fault(error); },
			writable: true
		},

		&#x2F;**
		 * Called when a subtask calls its cancel method. When a subtask is canceled
		 * any other subtasks that are dependent on the canceled task are cancled.
		 * 
		 * @for TaskGroup
		 * @method onSubTaskCancel
		 * @param {Task} task The task that was just cancled
		 *&#x2F;
		onSubTaskCancel: {
			value: function(task) {
				for (var i = 0; i &lt; this.tasks.length; i++) {
					if(isTaskDependentOnTask(this.tasks[i],task)){
						this.tasks[i].state = STATE_CANCELED;
					}
				}
			},
			writable: true
		},

		&#x2F;**
		 * Processes a sub task and prepares it for execution. This method overwrites the
		 * tasks on change functionality. If you wish to have a sub task that handles 
		 * its own change functionality then you will need to implement the partner 
		 * convenience methods.
		 * 
		 * @for TaskGroup
		 * @method processSubTask
		 * @param {Task} task Subtask to process
		 *&#x2F;
		processSubTask: {
			value: function(task) {

				if(!task) throw UNDEFINED_TASK;

				if(task.state == STATE_CANCELED) {
					this.onSubTaskCancel(task);
					return true;
				}

				task.group = this;
				task.loggingEnabled = this.loggingEnabled;

				&#x2F;&#x2F; set execution block
				task.onChange = function(state, error) {
					if(state == STATE_COMPLETED) this.group.onSubTaskComplete();
					else if(state == STATE_FAULTED) this.group.onSubTaskFault(error);
					else if(state == STATE_CANCELED) this.group.onSubTaskCancel(task);
				}

				task.start();

				return false;
			},
			writable: true
		},

		&#x2F;**
		 * Removes a task from its group. Removing the task after it has executed will
		 * have no apparent affect as it has already ran.
		 * 
		 * @for TaskGroup
		 * @method removeSubTask
		 * @param {Task} task The task you wish to remove from the group.
		 *&#x2F;
		removeSubTask: {
			value: function(task) {
				if(!task) return;
				var index = this.tasks.indexOf(task);
				this.tasks.splice(index, 1);
			},
			writable: true
		},

		&#x2F;**
		 * Return a Task object, if it exists, based on the &#x60;tid&#x60; passed.
		 * 
		 * @for TaskGroup
		 * @method getTaskByTid
		 * @param {String} tid The id of the task you want
		 * @example

			var parallel = new MonkeyBars.ParallelTask({
				tasks:[task1,task3]
			});

			parallel.getTaskByTid(task1.tid);

		 *&#x2F;
		getTaskByTid: {
			value: function(tid) {
				for(var i = 0; i &lt; this.tasks.length; i++) {
					var task = this.tasks[i];
					if(task.tid == tid) return task;
				};
			},
			writable: true
		},

		&#x2F;**
		 * Return a Task object, if it exists, based on the &#x60;id&#x60; passed.
		 * 
		 * @for TaskGroup
		 * @method getTaskById
		 * @param {String} id The user defined id
		 *&#x2F;
		getTaskById: {
			value: function(id) {
				for(var i = 0; i &lt; this.tasks.length; i++) {
					var task = this.tasks[i];
					if(task.id == id) return task;
				};
			},
			writable: true
		},

		&#x2F;**
		 * Return a Task object, if it exists, based on the &#x60;name&#x60; passed.
		 * 
		 * @for TaskGroup
		 * @method getTaskByName
		 * @param {String} name The user defined name
		 *&#x2F;
		getTaskByName: {
			value: function(name) {
				for(var i = 0; i &lt; this.tasks.length; i++) {
					var task = this.tasks[i];
					if(task.name == name) return task;
				};
			},
			writable: true
		},

		&#x2F;**
		 * Cancel the group and cancel all of its subtasks
		 * 
		 * @for TaskGroup
		 * @method cancel
		 *&#x2F;
		cancel:{
		 	value:function(){

		 		&#x2F;&#x2F; call cancel on this task
		 		Task.prototype.call(this);
		 		
		 		&#x2F;&#x2F; cancel all of this tasks subtasks
		 		for (var i = 0; i &lt; this.tasks.length; i++) {
		 			&#x2F;&#x2F; we only want to cancel those tasks that are currently running
					&#x2F;&#x2F; otherwise we want to set the canceled flag
		 			var task = this.tasks[i];
		 			if (task.state&gt;STATE_INITIALIZED){
		 				task.cancel();
		 			} else {
		 				task.state = STATE_CANCELED;
		 			}
		 		};

			},
			writable: true
		},

		&#x2F;**
		 * Sets dependencies for the passed task.
		 *
		 * @method setDependeciesForTask
		 * @param {Task} task
		 * @static
		 *&#x2F;
		setDependeciesForTask: {
		 	value:function(task){
				if(task.dependencies){
					var totalDependencies = task.dependencies.length;
					for (var i = 0; i &lt; totalDependencies; i++) {
						var dependency = task.dependencies[i];
						if(dependency.tid) {
							this.dependencyMap[task.tid].push(dependency.tid);
						} else {
							this.dependencyMap[task.tid].push(dependency);
						}
					};

				}
			},
			writable: false
		}
	});

	&#x2F;**
	 * A ParallelTask is a TaskGroup that runs all of its subtasks ansynchronously. Its
	 * complete functionality is run when all of its sub tasks are complete.
	 * 
	 * @extends TaskGroup
	 * @constructor
	 * @class ParallelTask
	 * @param {Object} attributes List of attributes to apply to the task group
	 * @example

			var parallel = new MonkeyBars.ParallelTask({
				name:&quot;ParallelTask&quot;,
				tasks:[new MonkeyBars.Task({
					performTask:function(){
						this.complete();
					}
				})],
				onComplete:function(){
					alert(this.name + &quot; is complete!&quot;);
				}
			});

			parallel.start();

	 *&#x2F;
	var ParallelTask = MonkeyBars.ParallelTask = function(attributes) {
	 	&#x2F;&#x2F; refernce for readability
	 	var task = this;

	 	&#x2F;&#x2F; super
	 	TaskGroup.call(task,attributes);
	 }

	ParallelTask.prototype = Object.create(TaskGroup.prototype, {

		&#x2F;**
		 * The kind of task 
		 * 
		 * @for ParallelTask
		 * @property type
		 * @type String
		 * @readonly
		 *&#x2F;
		type: {
			get: function() {
				return TYPE_PARALLEL;
			}
		},

		&#x2F;**
		 * Checks whether or not the group has any enabled sub tasks.
		 * 
		 * @for ParallelTask
		 * @method hasNoEnabledSubTasks
		 * @return {Boolean} Has sub tasks or not
		 *&#x2F;
		hasNoEnabledSubTasks: {
			value: function() {
				if(!this.tasks) return true;
				for(var i = 0; i &lt; this.tasks.length; i++) {
					var task = this.tasks[i];
					if(task.state != STATE_CANCELED) return false;
				}
				return true;
			},
			writable: true
		},

		&#x2F;**
		 * Processes all of the sub tasks available for the group
		 * 
		 * @for ParallelTask
		 * @method processSubTasks
		 *&#x2F;
		processSubTasks: {
			value: function() {
				for(var i = 0; i &lt; this.tasks.length; i++) {
					var task = this.tasks[i];
					this.currentIndex++;
					this.processSubTask(task);
				}
			},
			writable: true
		},

		&#x2F;**
		 * This method is overridden from &#x60;TaskGroups&#x60; implementation because of the 
		 * nature of a parallel task. When a task is added it should be immediately
		 * processed and started.
		 * 
		 * @for ParallelTask
		 * @method addSubTask
		 * @param {Object} task Either an object containing attributes of a task or
		 *&#x2F;
		addSubTask: {
			value: function(task) {
				if(!task || task.state == STATE_CANCELED) return;
				this.currentIndex++;
				if(!task.tid) task = createTaskWithOptions(task);
				this.tasks.push(task);
				this.processSubTask(task);
			},
			writable: true
		},

		&#x2F;**
		 * Overridden from TaskGroup. This method is run everytime a sub task
		 * completes. When all subtasks are complete the groups complete method
		 * is called.
		 * 
		 * @for ParallelTask
		 * @method onSubTaskComplete
		 *&#x2F;
		onSubTaskComplete: {
			value: function() {
				this.currentIndex = this.currentIndex++;
				if(this.currentIndex == this.tasks.length) {
					this.complete();
				}
			},
			writable: true
		},

		&#x2F;**
		 * Overridden from Task. First checks to see if there are any enabled
		 * subtasks to process. If there arent the groups complete method is called.
		 * If there are then the group processes all of the sub tasks it has.
		 * 
		 * @for ParallelTask
		 * @method performTask
		 *&#x2F;
		performTask: {
			value: function() {
				if(this.hasNoEnabledSubTasks()) {
					this.complete();
				} else {
					this.processSubTasks();
				}
			},
			writable: true
		}
	});

	&#x2F;**
	 * A SequenceTask is a TaskGroup that runs all of its subtasks serially. Its
	 * complete functionality is run when all of its sub tasks are complete.
	 * 
	 * @extends TaskGroup
	 * @constructor
	 * @class SequenceTask
	 * @param {Object} attributes List of attributes to apply to the task group
	 * @example

			var sequence = new MonkeyBars.SequenceTask({
				name:&quot;ParallelTask&quot;,
				tasks:[new MonkeyBars.Task({
					performTask:function(){
						this.complete();
					}
				})],
				onComplete:function(){
					alert(this.name + &quot; is complete!&quot;);
				}
			});

			sequence.start();

	 *&#x2F;
	var SequenceTask = MonkeyBars.SequenceTask = function(attributes){
	 	&#x2F;&#x2F; refernce for readability
	 	var task = this;

	 	&#x2F;&#x2F; super
	 	TaskGroup.call(task,attributes);
	 }

	SequenceTask.prototype = Object.create(TaskGroup.prototype, {
		
		&#x2F;**
		 * The kind of task 
		 * 
		 * @for SequenceTask
		 * @property type
		 * @type String
		 * @readonly
		 *&#x2F;
		type: {
			get: function() {
				return TYPE_SEQUENCE;
			}
		},

		&#x2F;**
		 * Starts the next task in the queue after its previous sibling has completed.
		 * 
		 * @for SequenceTask
		 * @method startNextSubTask
		 *&#x2F;
		startNextSubTask: {
			value: function() {
				if(this.state &gt;= STATE_CANCELED) return;
				if(this.tasks &amp;&amp; this.currentIndex &lt; this.tasks.length) {
					var skipped = this.processSubTask(this.tasks[this.currentIndex++]);
					if(skipped) this.startNextSubTask();
				} else {
					this.complete();
				}
			},
			writable: true
		},

		&#x2F;**
		 * Overridden from TaskGroup. As long as the group has not been canceled,
		 * when a sub task completes it starts the next sibling in the queue.
		 * 
		 * @for SequenceTask
		 * @method onSubTaskComplete
		 *&#x2F;
		onSubTaskComplete: {
			value: function() {
				if(this.state == STATE_CANCELED) return;
				this.startNextSubTask();
			},
			writable: true
		},

		&#x2F;**
		 * Overriden from TaskGroup. As long as the group has not been canceled,
		 * when a sub task is canceled it simply moves on to the next task in the queue.
		 * 
		 * @for SequenceTask
		 * @method onSubTaskCancel
		 * @param {Task} task 
		 *&#x2F;
		onSubTaskCancel: {
			value: function(task) {
				TaskGroup.prototype.onSubTaskCancel.call(this,task);
				if(this.state != STATE_CANCELED) this.startNextSubTask();
			},
			writable: true
		},

		&#x2F;**
		 * Starts the next sub task in the sequence. If overriden you need to call the 
		 * SequenceTask&#x27;s prototype &#x60;performTask&#x60; method.
		 * 
		 * @for SequenceTask
		 * @method performTask
		 * @param {Task} task 
		 *&#x2F;
		performTask: {
			value: function() {
				this.startNextSubTask();
			},
			writable: true
		}
	});

	&#x2F;&#x2F; add the extend functionality to all of the task constructor functions
	Task.extend = TaskGroup.extend = ParallelTask.extend = SequenceTask.extend = extend;

	&#x2F;&#x2F; ===================================================================
	&#x2F;&#x2F; === Task Decorators ===============================================
	&#x2F;&#x2F; ===================================================================

	&#x2F;**
	 * Decorator to provide for loop functionality for the task. The task executes
	 * as many times as referenced by the count attribute provided by the instance.
	 * 
	 * @for MonkeyBars
	 * @method ForTaskDecorator
	 * @param {Object} task
	 * @private
	 *&#x2F;
	var ForTaskDecorator = function(task) {
		task.decorators.push(DECORATOR_FOR);
	 	task.itterationIndex = 0;
	 	task.complete = function() {
			if(this.itterationIndex != this.count - 1) {
				resetTask(this);
				this.itterationIndex++;
				if(this.loggingEnabled) console.log(&quot;Completed:&quot; + this.displayName + &quot; &quot; + this.itterationIndex + &quot; out of &quot; + this.count + &quot; times&quot;);
				this.performTask();
			} else {
				Task.prototype.complete.call(this);
			}
		}
	}

	&#x2F;**
	 * Decorator to provide while loop functionaliy. The task executed until the &#x60;while&#x60;
	 * method returns false.
	 * 
	 * @for MonkeyBars
	 * @method WhileTaskDecorator
	 * @param {Object} task
	 * @private
	 *&#x2F;
	var WhileTaskDecorator = function(task) {
		task.decorators.push(DECORATOR_WHILE);
		task.interval = task.interval ? task.interval : TIMEOUT_INTERVAL;
		task.complete = function() {
			if(this.while()) {
				this.state = STATE_INITIALIZED;
				var delegate = this;
				if(this.interval != 0) {
					setTimeout(function() { delegate.start(); }, this.interval);
				} else {
					delegate.start();
				}

			} else {
				Task.prototype.complete.call(this);
			}
		}
	}

	&#x2F;**
	 * The task doesnt execute until the when method provided returns true.
	 *
	 * @for MonkeyBars
	 * @method WhenTaskDecorator
	 * @param {Object} task
	 * @private
	 *&#x2F;
	var WhenTaskDecorator = function(task) {
		task.decorators.push(DECORATOR_WHEN);
		task.interval = task.interval ? task.interval : TIMEOUT_INTERVAL;
		task.start = function(){
			if(this.when()){
				Task.prototype.start.call(this);
			}else{
				var delegate = this;
				setTimeout(function(){ delegate.start(); },this.interval);
			}
		}
	}

	&#x2F;&#x2F; ===================================================================
	&#x2F;&#x2F; === Public Interface ==============================================
	&#x2F;&#x2F; ===================================================================

	&#x2F;**
	 * description needed
	 *
	 * @property TaskStates
	 * @for MonkeyBars
	 * @type Object
	 * @static
	 *&#x2F;
	MonkeyBars.TaskStates = {
		Initialized:STATE_INITIALIZED,
		Started:STATE_STARTED,
		Canceled:STATE_CANCELED,
		Faulted:STATE_FAULTED,
		Completed:STATE_COMPLETED
	};

	&#x2F;**
	 * description needed
	 *
	 * @property TaskTypes
	 * @for MonkeyBars
	 * @type Object
	 * @static
	 *&#x2F;
	MonkeyBars.TaskTypes = {
		Parallel:TYPE_PARALLEL,
		Sequence:TYPE_SEQUENCE,
		Simple:TYPE_SIMPLE
	};

	&#x2F;**
	 * description needed
	 *
	 * @property TaskDecorators
	 * @for MonkeyBars
	 * @type Object
	 * @static
	 *&#x2F;
	MonkeyBars.TaskDecorators = {
		For:DECORATOR_FOR,
		When:DECORATOR_WHEN,
		While:DECORATOR_WHILE
	};

}(this));
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
